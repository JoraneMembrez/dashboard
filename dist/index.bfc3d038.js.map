{"mappings":"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","sources":["starter/app.js"],"sourcesContent":["\"use strict\";\r\n\r\n// getCoordinates()\r\n// Demande au navigateur de dÃ©tecter la position actuelle de l'utilisateur et retourne une Promise\r\nconst getCoordinates = () => {\r\n  return new Promise((res, rej) =>\r\n    // getCurrentPosition --> permet d'avoir la localisation gÃ©ogrpahique actuelle du pÃ©riphÃ©rique\r\n    navigator.geolocation.getCurrentPosition(res, rej)\r\n  );\r\n};\r\n\r\n// getPosition()\r\n// RÃ©sout la promesse de getCoordinates et retourne un objet {lat: x, long: y}\r\nconst getPosition = async () => {\r\n  const position = await getCoordinates();\r\n  return {\r\n    lat: position.coords.latitude,\r\n    long: position.coords.longitude,\r\n  };\r\n};\r\n\r\n// renderWeather(min, max)\r\n// Affiche la valeu des deux paramÃªtres dans le widget de mÃ©tÃ©o\r\nconst renderWeather = (min, max) => {\r\n  document.querySelector(\".min\").textContent = `${min}Â°C`;\r\n  document.querySelector(\".max\").textContent = `${max}Â°C`;\r\n  return;\r\n};\r\n\r\n// parseStationData(rawData)\r\n// ReÃ§oit la rÃ©ponse JSON de l'API Transport/stationboard et recrache un objet\r\n// ne contenant que les informations pertinentes.\r\nconst parseStationData = (rawData) => {\r\n  const { stationboard } = rawData;\r\n  const departures = stationboard.map((el) => {\r\n    const date = new Date(el.stop.departure);\r\n    const hours = date.getHours();\r\n    const minutes = date.getMinutes();\r\n    const formattedHours = date.getHours() < 10 ? \"0\" + hours : hours;\r\n    const formattedMinutes = date.getMinutes() < 10 ? \"0\" + minutes : minutes;\r\n    return {\r\n      departure: `${formattedHours}:${formattedMinutes}`,\r\n      destination: el.to,\r\n      category: el.category,\r\n    };\r\n  });\r\n  return {\r\n    station: rawData.station.name,\r\n    departures,\r\n  };\r\n};\r\n\r\n// renderTrain(train)\r\n// Affiche une ligne de dÃ©part dans le widget CFF.\r\nconst renderTrain = (train) => {\r\n  const board = document.querySelector(\".departures\");\r\n  const html = `\r\n    <article>\r\n        <div class=\"time\">${train.departure}</div>\r\n        <div class=\"category\" data-category=\"${train.category}\">${train.category}</div>\r\n        <div class=\"destination\">${train.destination}</div>\r\n    </article>\r\n    `;\r\n  board.insertAdjacentHTML(\"beforeend\", html);\r\n  return;\r\n};\r\n\r\n// renderStationName(station)\r\n// Affiche le mot passÃ© en paramettre dans le widget CFF.\r\nconst renderStationName = (station) => {\r\n  const stationElement = document.querySelector(\".departures header p\");\r\n  stationElement.textContent = station;\r\n};\r\n\r\n// Votre code peut se trouver dans cette fonction. L'appel vers getPosition est\r\n// dÃ©jÃ  implÃ©mentÃ©. Si vous jetez un coup d'oeil Ã  votre console vous verrez un objet\r\n// contenant votre position.\r\n\r\nconst getDashboardInformation = () => {\r\n  // Cherche la position\r\n  getPosition()\r\n    // Puis fait une requÃªte paralelle vers les API en fonction des gÃ©odonnÃ©es\r\n    .then((res) => {\r\n      const transportURL = `http://transport.opendata.ch/v1/locations?x=${res.lat}&y=${res.long}&type=station`;\r\n      const weatherURL = `https://api.open-meteo.com/v1/forecast?latitude=${res.lat}&longitude=${res.long}&daily=apparent_temperature_max,apparent_temperature_min&timezone=auto`;\r\n      return Promise.all([\r\n        fetch(transportURL).then((el) => el.json()),\r\n        fetch(weatherURL).then((el) => el.json()),\r\n      ]);\r\n    })\r\n    // Puis affiche les donnÃ©es MÃ©tÃ©o et regarde si il y a une station Ã  proximitÃ©\r\n    .then((data) => {\r\n      const [transport, weather] = data;\r\n      renderWeather(\r\n        weather.daily.apparent_temperature_min[0],\r\n        weather.daily.apparent_temperature_max[0]\r\n      );\r\n      const station = transport.stations.filter(\r\n        (station) => station.icon === \"train\"\r\n      )[0];\r\n      // Si c'est le cas, va chercher les prochains dÃ©parts\r\n      if (station) {\r\n        return fetch(\r\n          `https://transport.opendata.ch/v1/stationboard?station=${station.name}&limit=6`\r\n        ).then((res) => res.json());\r\n        // Sinon balance une erreur\r\n      } else {\r\n        throw new Error(\"No train stations nearby\");\r\n      }\r\n    })\r\n    // ReÃ§oit les donnÃ©es d'une station si celle-ci existe et affiche les trains\r\n    .then((data) => {\r\n      const stationData = parseStationData(data);\r\n      renderStationName(stationData.station);\r\n      stationData.departures.forEach((train) => {\r\n        renderTrain(train);\r\n      });\r\n    })\r\n    // Attrape les erreur tout au long de la chaine et les affiche dans le widget CFF\r\n    .catch((err) => {\r\n      console.error(err.message);\r\n      const station = document.querySelector(\".departures p\");\r\n      station.textContent = `ðŸ˜¢ ${err.message}`;\r\n    });\r\n};\r\n\r\ngetDashboardInformation();\r\n"],"names":[],"version":3,"file":"index.bfc3d038.js.map","sourceRoot":"/__parcel_source_root/"}